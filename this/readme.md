##### this 的5种绑定

- 默认绑定(非严格模式下this指向全局对象, 严格模式下this会绑定到undefined)
- 隐式绑定(当函数引用有上下文对象时, 如 obj.foo()的调用方式, foo内的this指向obj)
- 显示绑定(通过call()或者apply()方法直接指定this的绑定对象, 如foo.call(obj))
- new绑定
- 箭头函数绑定(this的指向由外层作用域决定的)

###### 1.默认绑定
    在非严格模式下this指向的是全局对象window，而在严格模式下会绑定到undefined。
- item1.1 - item1.5
###### 2.隐式绑定
    this 永远指向最后调用它的那个对象。
+ item2.1
###### 3.隐式绑定的隐式丢失问题
    隐式丢失其实就是被隐式绑定的函数在特定的情况下会丢失绑定对象。
- item3.x
###### 4.显示绑定
    通过call()、apply()或者bind()方法直接指定this的绑定对象
- 使用.call()或者.apply()的函数是会直接执行的
- bind()是创建一个新的函数，需要手动调用才会执行
- call()和apply()用法基本类似，不过call接收若干个参数，而apply接收的是一个数组
- 如果call、apply、bind接收到的第一个参数是空或者null、undefined的话，则会忽略这个参数。

###### 5.显式绑定的其它用法
    forEach、map、filter函数的第二个参数也是能显式绑定this的    
- this 永远指向最后调用它的那个对象
- 匿名函数的this永远指向window

###### 6.new 绑定
    使用new来调用一个函数，会构造一个新对象并把这个新对象绑定到调用函数中的this

###### 7.箭头函数绑定
>  它里面的this是由外层作用域来决定的，且指向函数定义时的this而非执行时。
- 7.1 字面量对象中普通函数与箭头函数的区别: 只有一层函数的题目 
- 7.2 字面量对象中普通函数与箭头函数的区别：函数嵌套的题目 
- 7.3 字面量对象中普通函数与箭头函数的区别：函数嵌套的题目
- 7.4 构造函数对象中普通函数和箭头函数的区别：一层函数的题目
- 7.5 构造函数对象中普通函数和箭头函数的区别：函数嵌套的题目
- 7.6 箭头函数的this无法通过bind、call、apply来直接修改，但是可以通过改变作用域中this的指向来间接修改。
> 避免使用场景:
> + 1.使用箭头函数定义对象的方法
> + 2.定义原型方法
> + 3.构造函数使用箭头函数
> + 4.作为事件的回调函数
